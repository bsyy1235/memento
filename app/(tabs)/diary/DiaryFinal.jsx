import {
  View,
  Text,
  TextInput,
  StyleSheet,
  StatusBar,
  Alert,
  TouchableOpacity,
  ScrollView,
  Image,
  PixelRatio,
  ActivityIndicator,
  Modal,
} from "react-native";
import React, { useState, useEffect } from "react";
import { Colors } from "../../../constants/Colors";
import { useDarkMode } from "../../../contexts/DarkModeContext.jsx";
import {
  getDiaryByDate,
  updateEmotion,
  getAudioFile,
} from "../../../utils/diary";
import { loadAccessToken } from "../../../utils/token";
import { format } from "date-fns";
import { formatDateHeader } from "../../../Logic/diaryFunction.jsx";
import { useRouter, useLocalSearchParams } from "expo-router";
import * as FileSystem from "expo-file-system";
import { Audio } from "expo-av";
import { useSoundLogic } from "../../../Logic/useSoundLogic";

function arrayBufferToBase64(buffer) {
  let binary = "";
  const bytes = new Uint8Array(buffer);
  const len = bytes.byteLength;
  for (let i = 0; i < len; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return global.btoa(binary); // Expo ÌôòÍ≤ΩÏóêÏÑú global.btoa ÏÇ¨Ïö©
}

export default function DiaryFinal({ route }) {
  const [showNewDiv, setShowNewDiv] = useState(false);
  const [diaryText, setDiaryText] = useState("");
  const [emotion, setEmotion] = useState("");
  const [comment, setComment] = useState("");
  const [date, setDate] = useState("");
  const [loading, setLoading] = useState(true);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);
  const { isDarkMode } = useDarkMode();
  const params = useLocalSearchParams();
  const initialDate = params?.date ? new Date(params.date) : new Date();
  const [selectedDate, setSelectedDate] = useState(initialDate);

  const {
    recordingUri,
    setRecordingUri,
    recordingDuration,
    setRecordingDuration,
    hasRecording,
    setHasRecording,
    sound,
    setSound,
    isPlaying,
    setIsPlaying,
    currentPosition,
    setCurrentPosition,
    playRecording,
    pausePlaying,
  } = useSoundLogic();

  const router = useRouter();
  if (!router) return null;

  useEffect(() => {
    if (params?.date) {
      const parsedDate = new Date(params.date);
      if (!isNaN(parsedDate)) setSelectedDate(parsedDate);
    }
  }, [params?.date]);

  useEffect(() => {
    const setDurationFromFile = async () => {
      if (recordingUri) {
        try {
          // Í∏∞Ï°¥ sound ÏûàÏúºÎ©¥ Ïñ∏Î°úÎìú
          if (sound) await sound.unloadAsync();
          const { sound: loadedSound } = await Audio.Sound.createAsync({
            uri: recordingUri,
          });
          setSound(loadedSound);
          const status = await loadedSound.getStatusAsync();
          if (status?.durationMillis) {
            setRecordingDuration(Math.floor(status.durationMillis / 1000));
          }
        } catch (e) {
          setRecordingDuration(0);
        }
      }
    };
    setDurationFromFile();
    return () => {
      if (sound) sound.unloadAsync();
    };
  }, [recordingUri]);

  const showDatepicker = () => {
    router.push("/diary");
  };

  // ÏãúÍ∞Ñ Ìè¨Îß∑ÌåÖ Ìï®Ïàò (00:00 ÌòïÏãù)
  function formatTime(sec) {
    sec = Math.floor(sec);
    const m = Math.floor(sec / 60)
      .toString()
      .padStart(2, "0");
    const s = (sec % 60).toString().padStart(2, "0");
    return `${m}:${s}`;
  }

  const [modalVisible, setModalVisible] = useState(false);
  const emotions = ["Í∏∞ÏÅ®", "Ïä¨Ìîî", "ÌôîÎÇ®", "ÏßÄÏπ®", "Ï§ëÎ¶Ω"];
  const handleChangeEmotion = async (newEmotion) => {
    try {
      await updateEmotion({
        date: format(selectedDate, "yyyy-MM-dd"),
        changeEmotion: newEmotion,
        mark_diary_written: true,
      });
      setEmotion(newEmotion); // ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
      setModalVisible(false);
      Alert.alert(
        "Í∞êÏ†ï ÏóÖÎç∞Ïù¥Ìä∏ ÏôÑÎ£å",
        `${newEmotion} Í∞êÏ†ïÏúºÎ°ú Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§.`
      );
    } catch {
      Alert.alert("Ïò§Î•ò", "Í∞êÏ†ï ÏóÖÎç∞Ïù¥Ìä∏Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.");
    }
  };

  useEffect(() => {
    const fetchDiary = async () => {
      const formattedDate = format(selectedDate, "yyyy-MM-dd");
      try {
        setLoading(true);
        console.log(selectedDate);
        const res = await getDiaryByDate(formattedDate);
        if (res) {
          setDiaryText(res.content || "");
          setDate(res.date || "");
          if (res.day) {
            setEmotion(res.day.emotion || "");
          }
          if (res.comment) {
            setComment(res.comment.content || "");
          }

          // ÏùåÏÑ± ÌååÏùº Í≤ΩÎ°úÍ∞Ä ÏûàÏúºÎ©¥ ÏÑúÎ≤ÑÏóêÏÑú ÌååÏùº Îã§Ïö¥Î°úÎìú ÌõÑ recordingUriÏóê Ï†ÄÏû•
          if (res.audio_path && res.id) {
            const diaryId = res.id;
            try {
              const token = await loadAccessToken();
              const audioUrl = await getAudioFile(diaryId); // URL Î∞òÌôò
              const localUri =
                FileSystem.cacheDirectory + `voice_${diaryId}.wav`;

              // === [1] Ïù∏Ï¶ù Ìè¨Ìï® fetchÎ°ú ÌååÏùº Î∞õÏïÑÏôÄ blobÏúºÎ°ú Î≥ÄÌôò ===
              const response = await fetch(audioUrl, {
                headers: {
                  Authorization: `Bearer ${token}`,
                },
              });

              if (!response.ok) {
                const text = await response.text();
                console.log("[DEBUG] fetch ÏùëÎãµ:", text);
                setRecordingUri(null);
                setHasRecording(false);
                return;
              }
              const blob = await response.blob();

              // === [2] blob ‚Üí base64 Î≥ÄÌôòÌï¥ÏÑú ÌååÏùº Ï†ÄÏû• ===
              const reader = new FileReader();
              reader.onloadend = async () => {
                const base64data = reader.result.split(",")[1];
                // Í∏∞Ï°¥ ÌååÏùº ÏÇ≠Ï†ú
                const existing = await FileSystem.getInfoAsync(localUri);
                if (existing.exists) await FileSystem.deleteAsync(localUri);

                await FileSystem.writeAsStringAsync(localUri, base64data, {
                  encoding: FileSystem.EncodingType.Base64,
                });

                // ÌååÏùº Ï°¥Ïû¨ Î∞è ÌÅ¨Í∏∞ ÌôïÏù∏
                const fileInfo = await FileSystem.getInfoAsync(localUri);
                console.log("[DEBUG] fileInfo:", fileInfo);
                if (!fileInfo.exists || fileInfo.size < 1000) {
                  setRecordingUri(null);
                  setHasRecording(false);
                  console.log(
                    "Ïò§ÎîîÏò§ ÌååÏùºÏù¥ Ï°¥Ïû¨ÌïòÏßÄ ÏïäÍ±∞ÎÇò ÏÜêÏÉÅÎê®:",
                    localUri
                  );
                  return;
                }

                setRecordingUri(localUri);
                setHasRecording(true);
              };
              reader.readAsDataURL(blob);
            } catch (audioErr) {
              setRecordingUri(null);
              setHasRecording(false);
              console.log("Ïò§ÎîîÏò§ ÌååÏùº Î∂àÎü¨Ïò§Í∏∞ Ïã§Ìå®:", audioErr);
            }
          } else {
            setRecordingUri(null);
            setHasRecording(false);
          }
        }

        setLoading(false);
      } catch (err) {
        console.warn("üì≠ ÏùºÍ∏∞ Î∂àÎü¨Ïò§Í∏∞ Ïã§Ìå®:", err);
        setError("ÏùºÍ∏∞Î•º Î∂àÎü¨Ïò§Îäî Îç∞ Ïã§Ìå®ÌñàÏäµÎãàÎã§. Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.");
        setLoading(false);
      }
    };
    fetchDiary();
  }, [selectedDate]);

  // Í∞êÏ†ïÏóê Îî∞Î•∏ ÏÉâÏÉÅ Ï≤òÎ¶¨
  const getEmotionColor = () => {
    switch (emotion) {
      case "Í∏∞ÏÅ®":
        return "#FFC0CB"; // ÌïëÌÅ¨
      case "Ïä¨Ìîî":
        return "#ADD8E6"; // Ïó∞Ìïú ÌååÎûë
      case "ÌôîÎÇ®":
        return "#FF6347"; // ÌÜ†ÎßàÌÜ† Î†àÎìú
      case "Ï§ëÎ¶Ω":
        return "#FFDCC4"; // Ï£ºÌô©
      case "ÏßÄÏπ®":
        return "#D8B1D6"; // Î≥¥ÎùºÏÉâ
      default:
        return "#E0E0E0"; // Í∏∞Î≥∏ ÌöåÏÉâ
    }
  };

  const renderLoading = () => {
    if (!isLoading) return null;

    return (
      <View
        style={{
          position: "absolute",
          top: 0,
          left: 0,
          right: 0,
          bottom: 0,
          backgroundColor: "rgba(0,0,0,0.4)",
          justifyContent: "center",
          alignItems: "center",
          zIndex: 10,
        }}
      >
        <View
          style={{
            backgroundColor: "white",
            padding: 20,
            borderRadius: 10,
            alignItems: "center",
          }}
        >
          <Text style={{ marginBottom: 10 }}>Î°úÎî© Ï§ëÏûÖÎãàÎã§...</Text>
          <ActivityIndicator size="large" color={Colors.primary} />
        </View>
      </View>
    );
  };

  if (error) {
    return (
      <View
        style={[
          styles.main,
          { justifyContent: "center", alignItems: "center" },
        ]}
      >
        <Text style={{ color: "red" }}>{error}</Text>
        <TouchableOpacity
          style={[
            {
              marginTop: 20,
              padding: 10,
              backgroundColor: isDarkMode ? "#efefef" : Colors.subPrimary,
              borderRadius: 5,
            },
          ]}
          onPress={() => {
            setError(null);
            setLoading(true);
            if (route?.params?.date) {
            }
          }}
        >
          <Text style={{ color: "white" }}>Îã§Ïãú ÏãúÎèÑ</Text>
        </TouchableOpacity>
      </View>
    );
  }

  return (
    <View style={styles.main}>
      <StatusBar style="auto" />
      {renderLoading()}
      <ScrollView>
        <View>
          <View style={styles.header}>
            <TouchableOpacity
              onPress={showDatepicker}
              style={styles.datePickerButton}
            >
              <Text style={styles.headerText}>
                {formatDateHeader(selectedDate)}
              </Text>
              <Image
                source={require("../../../assets/images/icons-right-arrow.png")}
                style={{ width: 20, height: 20, marginLeft: 10 }}
              />
            </TouchableOpacity>

            {recordingUri && recordingUri !== "empty" && (
              <View style={styles.audioControls}>
                <TouchableOpacity
                  onPress={() => {
                    if (isPlaying) {
                      pausePlaying();
                    } else {
                      playRecording(selectedDate);
                    }
                  }}
                  style={styles.micButton}
                >
                  <Image
                    source={
                      isPlaying
                        ? require("../../../assets/images/icons-pause-50.png")
                        : require("../../../assets/images/microphone.png")
                    }
                    style={{ width: 18, height: 18 }}
                  />
                </TouchableOpacity>
                {/* Ïû¨ÏÉù ÏãúÍ∞Ñ ÌëúÏãú */}
                {recordingDuration > 0 && (
                  <Text style={styles.audioTimeText}>
                    {formatTime(currentPosition / 1000)} /{" "}
                    {formatTime(recordingDuration)}
                  </Text>
                )}
              </View>
            )}

            {showNewDiv && (
              <TouchableOpacity onPress={() => setShowNewDiv(false)}>
                <Image
                  source={require("../../../assets/images/icons-left-arrow.png")}
                  style={{
                    width: 22,
                    height: 22,
                    alignItems: "center",
                    marginVertical: 12,
                  }}
                />
              </TouchableOpacity>
            )}
          </View>
          <View
            style={[
              styles.diaryDiv,
              {
                backgroundColor: isDarkMode
                  ? "rgba(255, 255, 255, 0.5)"
                  : "rgba(255,230,213, 0.5)",
              },
            ]}
          >
            <TextInput
              style={styles.divText}
              editable={false}
              multiline
              value={diaryText}
            />
          </View>

          {/* Í∞êÏ†ï ÌÇ§ÏõåÎìú */}
          <View style={styles.emotionBox}>
            <Text style={styles.subTitle}>Í∞êÏ†ï ÌÇ§ÏõåÎìú</Text>
            <View style={styles.emotionRow}>
              <View
                style={[
                  styles.emotionCircle,
                  { backgroundColor: getEmotionColor() },
                ]}
              ></View>
              <View style={styles.emotionColumn}>
                <View style={{ position: "relative" }}>
                  <Text style={{ fontSize: 10, marginLeft: 20 }}>
                    ÌïµÏã¨ Í∞êÏ†ï
                  </Text>
                  <Text style={{ fontSize: 22, marginLeft: 20 }}>
                    {emotion || "Ï†ïÎ≥¥ ÏóÜÏùå"}
                  </Text>
                  <View
                    style={{
                      position: "absolute",
                      bottom: -3,
                      left: 20,
                      height: 2,
                      backgroundColor: "black",
                      right: 0,
                    }}
                  />
                </View>
              </View>
              <View style={{ flex: 1, alignItems: "flex-end", marginTop: 30 }}>
                <TouchableOpacity
                  style={styles.emotionFeedbackButton}
                  onPress={() => setModalVisible(true)}
                >
                  <Text style={styles.feedbackButtonText}>
                    Î∂ÑÏÑùÎêú Í∞êÏ†ïÏù¥ ÎßûÏßÄ ÏïäÎÇòÏöî?
                  </Text>
                </TouchableOpacity>
                {/* Î™®Îã¨ Ï∞Ω */}
                <Modal
                  transparent
                  animationType="fade"
                  visible={modalVisible}
                  onRequestClose={() => setModalVisible(false)}
                >
                  <View style={styles.modalOverlay}>
                    <View style={styles.modalContent}>
                      <Text style={styles.modalTitle}>Í∞êÏ†ïÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî</Text>
                      {emotions.map((emotion) => (
                        <TouchableOpacity
                          key={emotion}
                          style={styles.emotionOption}
                          onPress={() => handleChangeEmotion(emotion)}
                        >
                          <Text style={styles.emotionText}>{emotion}</Text>
                        </TouchableOpacity>
                      ))}
                      <TouchableOpacity onPress={() => setModalVisible(false)}>
                        <Text style={styles.cancelText}>Ï∑®ÏÜå</Text>
                      </TouchableOpacity>
                    </View>
                  </View>
                </Modal>
              </View>
            </View>
          </View>

          {/* ÏΩîÎ©òÌä∏ */}
          <View>
            <Text style={styles.subTitle}>ÏΩîÎ©òÌä∏</Text>
            <View
              style={[
                styles.commentContainer,
                { backgroundColor: isDarkMode ? "white" : Colors.subPrimary },
              ]}
            >
              <Text style={{ fontSize: 15 }}>
                {" "}
                {comment || "ÏΩîÎ©òÌä∏ Ï†ïÎ≥¥Í∞Ä ÏóÜÏäµÎãàÎã§."}{" "}
              </Text>
            </View>
          </View>
        </View>
      </ScrollView>
    </View>
  );
}

const styles = StyleSheet.create({
  main: {
    flex: 1,
    marginVertical: 50,
    marginHorizontal: 25,
  },
  header: {
    alignItems: "center",
    justifyContent: "space-between",
    flexDirection: "row",
    marginBottom: 20,
  },
  subheader: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: 6,
    marginHorizontal: 4,
    opacity: 0.5,
  },
  headerText: {
    fontFamily: "roboto",
    fontSize: 25,
  },
  // diaryDiv ÏàòÏ†ï
  diaryDiv: {
    // backgroundColor: Colors.subPrimary,
    borderRadius: 10,
    minHeight: "10%", // ÏµúÏÜå ÎÜíÏù¥ ÏßÄÏ†ï
    flex: 1, // Î∂ÄÎ™® ScrollViewÏùò Í≥µÍ∞ÑÏùÑ Î™®Îëê Ï∞®ÏßÄÌïòÎèÑÎ°ù flex: 1 Ï∂îÍ∞Ä
    padding: 10,
    borderWidth: 0.5,
    borderColor: "rgba(158, 150, 150, .5)",
  },
  // divText ÏàòÏ†ï
  divText: {
    color: "black",
    fontSize: 15,
    fontFamily: "roboto",
    fontWeight: "400",
    height: "100%", // ÎÜíÏù¥Î•º Î∂ÄÎ™® Ïª®ÌÖåÏù¥ÎÑàÏóê ÎßûÏ∂§
    flex: 1, // TextInputÏù¥ diaryDiv ÎÇ¥Ïùò Í≥µÍ∞ÑÏùÑ Î™®Îëê Ï∞®ÏßÄÌïòÎèÑÎ°ù
    textAlignVertical: "top", // ÏïàÎìúÎ°úÏù¥ÎìúÏóêÏÑú ÌÖçÏä§Ìä∏Í∞Ä ÏÉÅÎã®ÏóêÏÑú ÏãúÏûëÌïòÎèÑÎ°ù
  },
  container_1: {
    // "ÏûÑÏãúÏ†ÄÏû•"
    justifyContent: "space-between",
    flexDirection: "row",
    paddingHorizontal: 19,
    paddingVertical: 11,
    borderRadius: 10,
    // backgroundColor: Colors.subPrimary,
    marginVertical: 15,
  },
  container: {
    // "ÏΩîÎ©òÌä∏ ÏöîÏ≤≠ÌïòÍ∏∞"
    justifyContent: "space-between",
    flexDirection: "row",
    paddingHorizontal: 17,
    paddingVertical: 15,
    borderRadius: 10,
    backgroundColor: "white",
    borderWidth: 0.5,
    borderColor: "rgba(158, 150, 150, .5)",
  },
  voice: {
    alignItems: "center",
    marginVertical: 12,
  },
  buttons: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  newDiv: {
    marginTop: 15,
    flex: 0.6,
    borderRadius: 10,
    justifyContent: "center",
    alignItems: "center",
    backgroundColor: "#fafafa",
  },
  finalPage: {
    padding: 20,
    backgroundColor: "#fff",
    flex: 1,
  },
  subTitle: {
    fontSize: 18,
    fontWeight: "bold",
    marginVertical: 10,
  },
  emotionBox: {
    alignItems: "left",
    marginVertical: 20,
  },
  emotionRow: {
    flexDirection: "row",
    alignItems: "center",
  },
  emotionColumn: {
    justifyContent: "center",
  },
  emotionCircle: {
    width: 70,
    height: 70,
    borderRadius: 40,
    backgroundColor: "#FFC0CB",
    justifyContent: "center",
    alignItems: "center",
  },
  commentContainer: {
    // backgroundColor: Colors.subPrimary,
    padding: 15,
    borderRadius: 10,
  },
  iconMarginHorizontal: {
    marginHorizontal: 100,
  },
  modalContainer: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    backgroundColor: "rgba(0, 0, 0, 0.5)",
  },
  modalContent: {
    width: "80%",
    backgroundColor: "white",
    borderRadius: 20,
    padding: 20,
    shadowColor: "#000",
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.25,
    shadowRadius: 4,
    elevation: 5,
  },
  datePickerButton: {
    flexDirection: "row",
    alignItems: "center",
  },
  dateLabel: {
    fontSize: 16,
    fontWeight: "bold",
    marginTop: 10,
    marginBottom: 5,
  },
  dateScroll: {
    maxHeight: 100,
    marginBottom: 10,
  },
  dateButtonContainer: {
    flexDirection: "row",
    paddingVertical: 10,
  },
  dateButton: {
    paddingHorizontal: 15,
    paddingVertical: 10,
    borderRadius: 20,
    marginHorizontal: 5,
  },
  selectedDateButton: {
    backgroundColor: Colors.subPrimary || "#FFE6D5",
  },
  selectedDateText: {
    fontWeight: "bold",
  },
  disabledDateText: {
    color: "#aaa",
  },
  cancelButton: {
    flex: 1,
    backgroundColor: "#ccc",
    paddingVertical: 10,
    borderRadius: 5,
    marginRight: 5,
    alignItems: "center",
  },
  confirmButton: {
    flex: 1,
    backgroundColor: Colors.subPrimary || "#FFE6D5",
    paddingVertical: 10,
    borderRadius: 5,
    marginLeft: 5,
    alignItems: "center",
  },
  dateScroll: {
    maxHeight: 100,
    marginBottom: 10,
  },
  dateButtonContainer: {
    flexDirection: "row",
    paddingVertical: 10,
  },

  modalButtons: {
    flexDirection: "row",
    justifyContent: "space-between",
    marginTop: 20,
  },
  disabledDateB4utton: {
    backgroundColor: "#f0f0f0",
    opacity: 0.5,
  },
  modalTitle: {
    fontSize: 20,
    fontWeight: "bold",
    marginBottom: 15,
    textAlign: "center",
  },
  buttonText: {
    fontSize: 16,
    fontWeight: "bold",
  },
  disabledDateButton: {
    backgroundColor: "#f0f0f0",
    opacity: 0.5,
  },
  emotionFeedbackButton: {
    backgroundColor: "#EEEEEE",
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 16,
    justifyContent: "flex-end",
  },
  feedbackButtonText: {
    fontSize: 12,
    color: "#666666",
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.4)",
    justifyContent: "center",
    alignItems: "center",
  },
  modalContent: {
    backgroundColor: "white",
    borderRadius: 10,
    padding: 24,
    width: "80%",
    alignItems: "center",
  },
  modalTitle: {
    fontSize: 16,
    fontWeight: "bold",
    marginBottom: 16,
  },
  emotionOption: {
    paddingVertical: 10,
    width: "100%",
    alignItems: "center",
  },
  emotionText: {
    fontSize: 15,
    color: "#444",
  },
  cancelText: {
    marginTop: 10,
    fontSize: 14,
    color: "#999",
  },
  micButton: {
    padding: 8,
    marginLeft: "auto",
    marginRight: "auto",
  },
  // ÏÉàÎ°ú Ï∂îÍ∞ÄÎêú Ïä§ÌÉÄÏùº
  audioControls: {
    flexDirection: "row",
    alignItems: "center",
  },
  audioTimeText: {
    fontSize: 12,
    color: "#666",
    marginLeft: 4,
    minWidth: 60,
  },
});
